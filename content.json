{"meta":{"title":"Mengqiu Chen","subtitle":"Blog of a human developer","description":"Learning is not enough, you must apply","author":"Roger Chen","url":"https://mengqiu.me","root":"/"},"pages":[{"title":"About","date":"2022-01-24T00:04:21.000Z","updated":"2022-01-26T15:08:43.751Z","comments":true,"path":"about/index.html","permalink":"https://mengqiu.me/about/","excerpt":"","text":"This is the blog of Mengqiu (Roger) Chen. This blog will record the learning path along becoming web backend developer. Roger is a backend developer base in Calgary. He has background knowledge of natural resouce conservation. With multiple industrial experiences, he eagers to apply them with programming skills."},{"title":"Tags","date":"2022-01-23T23:32:47.000Z","updated":"2022-01-23T23:33:40.684Z","comments":true,"path":"tags/index.html","permalink":"https://mengqiu.me/tags/","excerpt":"","text":""},{"title":"Categories","date":"2022-01-23T23:32:11.000Z","updated":"2022-01-23T23:33:46.447Z","comments":true,"path":"categories/index.html","permalink":"https://mengqiu.me/categories/","excerpt":"","text":""}],"posts":[{"title":"Serve static content","slug":"Serve-static-content","date":"2022-01-29T23:42:37.000Z","updated":"2022-01-29T23:49:23.513Z","comments":true,"path":"2022/01/29/Serve-static-content/","link":"","permalink":"https://mengqiu.me/2022/01/29/Serve-static-content/","excerpt":"Usually we put all the public content into public folder, including css, images etc. We should tell NodeJS to find the static folder.","text":"Usually we put all the public content into public folder, including css, images etc. We should tell NodeJS to find the static folder. Get root path of our project folderWe need a module called path 12const path = require(&#x27;path&#x27;);module.exports = path.dirname(require.main.filename); Then we can use this module for our root directory. Get static resourcesFor example, if we have file structure like this: shop.html that contains a link to css file &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot;&gt; and the css file is in public folder, we can’t access the css file by simply put public in front of the link like /public/css/main.css . We should use express.static to tell NodeJS which folder is the static resource folder, then when the server sends file, it knows where to fetch the content. In app.js, we need: 1app.use(express.static(path.join(__dirname, &#x27;public&#x27;))); When we call a module: 1app.use(shopRoutes); And the module sends a html page: 123router.get(&#x27;/&#x27;, (req, res, next) =&gt; &#123; res.sendFile(path.join(rootDir, &#x27;views&#x27;, &#x27;shop.html&#x27;));&#125;); This html page then can use the content of static folder 1&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot;&gt;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://mengqiu.me/categories/Javascript/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://mengqiu.me/tags/NodeJS/"},{"name":"Server","slug":"Server","permalink":"https://mengqiu.me/tags/Server/"}]},{"title":"Project: IPv4 auto subnetting API","slug":"Project-IPv4-auto-subnetting-API","date":"2022-01-28T17:18:04.000Z","updated":"2022-01-29T22:00:51.688Z","comments":true,"path":"2022/01/28/Project-IPv4-auto-subnetting-API/","link":"","permalink":"https://mengqiu.me/2022/01/28/Project-IPv4-auto-subnetting-API/","excerpt":"This is a review of my IPv4 knowledge that learnt two years ago. And This project will replace the old java command line program.You should be able to see the source code here: https://github.com/roger-mengqiu-chen/ipv4subnetting. You can try this web app here: https://ipv4-subnetting.herokuapp.com/","text":"This is a review of my IPv4 knowledge that learnt two years ago. And This project will replace the old java command line program.You should be able to see the source code here: https://github.com/roger-mengqiu-chen/ipv4subnetting. You can try this web app here: https://ipv4-subnetting.herokuapp.com/ Using this APIThe API will handle IPv4 subnetting automatically. It also handles the invalid user input. If the amount of required subnet address is too large, API will return &#39;Not enough address !&#39;. To send request to this API, you need follow the format as below: 12345678&#123; &quot;hostIp&quot;:&quot;210.100.56.0&quot;, &quot;mask&quot;:&quot;255.255.255.0&quot;, &quot;subnets&quot;:&#123; &quot;net1&quot;:2133, &quot;net2&quot;:4 &#125;&#125; Within “subnets”, you need to mention the name of your subnet and the required amount of hosts within this subnet.If the parent network has enough address, it will repond with JSON with following format: 1234567891011121314151617181920212223242526272829303132333435363738[ &#123; &quot;name&quot;: &quot;net2&quot;, &quot;ipAddress&quot;: [ 210, 100, 56, 32 ], &quot;numberOfHosts&quot;: 4, &quot;prefix&quot;: 29, &quot;mask&quot;: [ 255, 255, 255, 248 ], &quot;allocatedAddresses&quot;: 8 &#125;, &#123; &quot;name&quot;: &quot;net1&quot;, &quot;ipAddress&quot;: [ 210, 100, 56, 0 ], &quot;numberOfHosts&quot;: 21, &quot;prefix&quot;: 27, &quot;mask&quot;: [ 255, 255, 255, 224 ], &quot;allocatedAddresses&quot;: 32 &#125;] TheoryIPv4 networkIPv4 is 32 bit long IP address. We can divide the address into 4 sections, each of which is 8 bit long. In human-readable format, we separate these sections with “.” (e.g., 192.168.1.1).All of the IPv4 address can be converted to binary format: For example, 192.168.1.1 can be written in 11000000.10101000.00000001.00000001 Decimal Binary 192 1100 0000 168 1010 0000 1 0000 0001 Prefix and subnet maskPrefix is the number of “1”s in IPv4 binary format address from left to right. It is used to describe which part is the network address (The part with all “1”s is the network portion). For example, 192.168.1.1 /24Prefix /24 can be written in binary format:11111111 11111111 11111111 00000000The first 24 bits are all “1”s.To convert it to human-readable format, we use subnet mask:255.255.255.0 DecimalBinary 25511111111 Determine the networkIPv4 address has two portions: network portion and host portion. To determine the network portion, use logical AND for each bit: For example: 192.168.1.1 /24 Field Value IPv4 host 11000000 10101000 00000001 00000001 Subnet Mask 11111111 11111111 11111111 00000000 Logical AND 11000000 10101000 00000001 00000000 The logical AND result is network address: 192.168.1.0 And the host portion is last \".1\". (i.e., the last 8 bits of IPv4 binary address) Assign the number of IP addresses according to the number of hostsEach network has 2 reserved addresses: broadcast address and network address. Broadcast address is the address with all “1”s in host portion (e.g., 192.168.1.0 /24 broadcast address is 192.168.1.255). Network address is the address with all “0”s in host portion (e.g., 192.168.1.128 /25 network address is 192.168.1.128) Each bit of the network address can hold 2 host addresses (0 and 1). When we allocate IP address for hosts, we caculate the required bits from right to left. For example, if we want to take 6 addresses from 192.168.1.0 /24 network: Convert IP address to binary form: 11000000 10101000 00000001 00000000 6 ≈ 2^3, so 3 bits will be used The rightmost 3 bits are the host part. The rest is network part The prefix is 32 - 3 = 29. The mask is 11111111 11111111 11111111 11111000, which is 255.255.255.248 When we allocate addresses to hosts, remember to add broadcast and network address to the required number of hosts (i.e., 4 required hosts need at least 6 addresses). Divide the parent network according to the required number of host addressesMy strategy is sorting the subnets according to their size. Then allocate addresses from the biggest one. For example, network address is 192.168.1.0 /24 and the table below is the required hosts for each network network namehosts network12 network220 network36 Then we can allocate addresses as below: network name allocated addresses prefix network23227 network3829 network1430 Finally, allocate network addresses from the biggest one network name network address network2192.168.1.0 network3192.168.1.32 network1192.168.1.40","categories":[{"name":"Project","slug":"Project","permalink":"https://mengqiu.me/categories/Project/"}],"tags":[{"name":"IPv4","slug":"IPv4","permalink":"https://mengqiu.me/tags/IPv4/"},{"name":"REST","slug":"REST","permalink":"https://mengqiu.me/tags/REST/"},{"name":"API","slug":"API","permalink":"https://mengqiu.me/tags/API/"}]},{"title":"Express basic routing","slug":"Express-basic-routing","date":"2022-01-27T03:15:27.000Z","updated":"2022-01-28T04:16:16.915Z","comments":true,"path":"2022/01/26/Express-basic-routing/","link":"","permalink":"https://mengqiu.me/2022/01/26/Express-basic-routing/","excerpt":"Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. In express, everything is middleware.","text":"Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. In express, everything is middleware. Express 4.x API Install express:1npm install --save express Basic request/response handlingLet’s create a simple routing here: 1234567891011121314151617const http = require(&#x27;http&#x27;);const express = require(&#x27;express&#x27;); // check the source code, it exports a functionconst app = express();app.use((req, res, next) =&gt; &#123; // use add a middleware to the stack console.log(&#x27;in the middleware&#x27;); next(); // allows the request to continue to the next middleware&#125;);app.use((req, res, next) =&gt; &#123; console.log(&#x27;in another middleware&#x27;); res.send(&#x27;&lt;h1&gt;hello from express&lt;/h1&gt;&#x27;);&#125;)app.listen(3000); After running the code above, got to “localhost:3000”, we will get “hello from express” in the browser and two messages in console. We can add some specific path for handling. For example: 1app.use(&#x27;/path&#x27;, (req, res, next) =&gt; &#123;...&#125;); The default path is /, if we don’t specify any path here NodeJS parse from top to bottom, if one function doesn’t have next() in its body, it will block the code and request won’t go to the next function. For example: 123456789app.use (&#x27;/&#x27;, (req, res, next) =&gt; &#123; console.log(&#x27;always run&#x27;); next();&#125;);app.use(&#x27;/add-product&#x27;, (req, res, next) =&gt; &#123; console.log(&#x27;in another middleware&#x27;); res.send(&#x27;&lt;h1&gt;Add product&lt;/h1&gt;&#x27;);&#125;) When we send request ‘/add-product’, The first app.use() has next(), so the second one will be reached and send response back. If the first one doesn’t have next() , the second one won’t be executed, the page will keep loading because there’s no response sent back. To parse request body, we need package called body-parser 1npm install --save body-parser And use bodyParser before all the middlewares 1app.use(bodyParser.urlencoded(&#123;extended: false&#125;)); app.use will handle all types of requests. To handle POST request particularly, just change use to post. 1app.post(&#x27;/path&#x27;, (req, res, next) =&gt; &#123;...&#125;); To handle other http requests, we just need to change it to put, get, etc. Express routingWe can construct some modules to improve reusability: For example, we can make an admin module to handle get request /add-product to get form data for adding product and post request /product to post form data: 12345678910111213const express = require(&#x27;express&#x27;);const router = express.Router();// below will get a form router.get(&#x27;/add-product&#x27;, (req, res, next) =&gt; &#123; res.send(&#x27;&lt;form action=&quot;/product&quot; method=&quot;POST&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;&lt;button type=&quot;submit&quot;&gt;Add product&lt;/button&gt;&lt;/form&gt;&#x27;);&#125;); // below will post the form datarouter.post(&#x27;/product&#x27;, (req, res, next) =&gt; &#123; console.log(req.body); res.redirect(&#x27;/&#x27;); // once print out the body of request, redirect to /&#125;);module.exports = router; Then we can use this module in our entry point (app.js for this example): 1234567const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const adminRoutes = require(&#x27;./admin&#x27;);const app = express();app.use(bodyParser.urlencoded(&#123;extended: false&#125;));app.use(adminRoutes);app.listen(3000); // this will create server and listen on 3000 Difference between app.use() and router.get()1234567const express = require(&#x27;express&#x27;);const app = express();const router = express.Router();app.use(&#x27;/first&#x27;, router); // mount the router as middleware at path /firstrouter.get(&#x27;/sud&#x27;, smaller);router.get(&#x27;/user&#x27;, bigger); When sending /first/sud smaller function will be called. If you open /first/user, then the bigger function will get called. app mounts middleware first, router set subpath accordingly 123app.use(&#x27;/first&#x27;, fun);app.get(&#x27;/sud&#x27;, bigger);app.get(&#x27;/user&#x27;, smaller); In the code above, functions will be called at /first, /sud, /user. If we call /first/sud, there’s no response. Filtering pathsIf request type is different, it can have the same path. For example 12router.get(&#x27;/add-product&#x27;...)router.post(&#x27;/add-product&#x27;...) app.use can have filtering path 1app.use(&#x27;/admin&#x27;, adminRouters) If we have route.get(’/add-product’ ...) within adminRouters, we need send request ‘/admin/add-product’ to get result.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://mengqiu.me/categories/Javascript/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://mengqiu.me/tags/NodeJS/"},{"name":"Server","slug":"Server","permalink":"https://mengqiu.me/tags/Server/"},{"name":"Routing","slug":"Routing","permalink":"https://mengqiu.me/tags/Routing/"}]},{"title":"Creating a server with NodeJS","slug":"Creating-a-server-with-NodeJS","date":"2022-01-26T02:21:29.000Z","updated":"2022-01-26T02:23:19.872Z","comments":true,"path":"2022/01/25/Creating-a-server-with-NodeJS/","link":"","permalink":"https://mengqiu.me/2022/01/25/Creating-a-server-with-NodeJS/","excerpt":"To create a server, we need http module. The application also should keep running with listening to a port. We also need write some code to deal with received request and sending response.","text":"To create a server, we need http module. The application also should keep running with listening to a port. We also need write some code to deal with received request and sending response. CreatingExample: 12345678910111213141516const http = require(&#x27;http&#x27;);function rqListener(req, res) &#123; // using req, res is common practice console.log(req.url, req.method, req.headers); // process.exit(); // close down the server once print the result res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;); // attach a header to response, telling the type is html res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); res.end(); // This is the end; content after this point won&#x27;t be sent&#125;const server = http.createServer(rqListener); // have to pass a callback function when create a serverserver.listen(3000); // this will keep running These codes will send a page with title as “Test” and content-type is “text/html” RoutingWe can add some if statements to handle the request and send response accordingly. Example: 12345678910const url = req.url; const method = req.method; if (url === &#x27;/&#x27;) &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;); // attach a header to response, telling the type is html res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;Enter message&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;form action=&quot;/message&quot; method=&quot;POST&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); return res.end(); // This is the end; content after this point won&#x27;t be sent &#125; These code will send back a form with input box to user when user sends request 123456if (url === &#x27;/message&#x27; &amp;&amp; method === &#x27;POST&#x27;) &#123; fs.writeFileSync(&#x27;message.txt&#x27;, &#x27;dummy&#x27;); res.statusCode = 302; res.setHeader(&#x27;Location&#x27;, &#x27;/&#x27;); return res.end();&#125; The code above will see if user send ‘/message’ POST request. If so, create a file called ‘message.txt’ and save ‘dummy’ into that file. Then return code 302 and redirect page to ‘ localhost:port/ ’. Parsing request dataWe can set event listener on request with on. For example: 1234567891011121314const body = [];// listen on data eventreq.on(&#x27;data&#x27;, (chunk) =&gt; &#123; console.log(chunk); body.push(chunk); console.log(body);&#125;);// listen on end eventreq.on(&#x27;end&#x27;, () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); console.log(parsedBody); // print message=... const message = parsedBody.split(&#x27;=&#x27;)[1]; // get content after = fs.writeFileSync(&#x27;message.txt&#x27;, message);&#125;); The &#39;data&#39; event emits either a Buffer (by default) or a string if setEncoding() was used. In the code above, when the event happens, print out the chunk of this data and push it into an array. The &#39;end&#39; event is emitted when the stream has received an EOF (FIN in TCP terminology). Indicates that no more &#39;data&#39; events will happen. If the stream is also writable, it may be possible to continue writing. In the code above, the data is stored in a text file.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://mengqiu.me/categories/Javascript/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://mengqiu.me/tags/NodeJS/"},{"name":"Server","slug":"Server","permalink":"https://mengqiu.me/tags/Server/"}]},{"title":"Callback vs Promise vs Async","slug":"Callback-vs-Promise-vs-Async","date":"2022-01-25T19:28:34.000Z","updated":"2022-01-25T19:42:42.720Z","comments":true,"path":"2022/01/25/Callback-vs-Promise-vs-Async/","link":"","permalink":"https://mengqiu.me/2022/01/25/Callback-vs-Promise-vs-Async/","excerpt":"When passing a function to another function as a parameter, the passed function is called callback function. A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action’s eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.","text":"When passing a function to another function as a parameter, the passed function is called callback function. A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action’s eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future. An async function is a function declared with the async keyword, and the await keyword is permitted within it. The async and await keywords enable asynchronous, promise-based behaviour to be written in a cleaner style, avoiding the need to explicitly configure promise chains. To explain these three concepts, we can use example provided in https://www.youtube.com/watch?v=PoRJizFvM7s If we have posts: 1234const posts = [ &#123;title: &#x27;post 1&#x27;, body: &#x27;this is post one&#x27;&#125;, &#123;title: &#x27;post 2&#x27;, body: &#x27;this is post two&#x27;&#125;]; And getPosts function: 123456789function getPosts() &#123; setTimeout(function() &#123; let output = &#x27;&#x27;; posts.forEach((post) =&gt; &#123; output += `&lt;li&gt;$&#123;post.title&#125;&lt;/li&gt;`; &#125;); document.body.innerHTML = output; &#125;, 1000);&#125; Callback example:We can have a function to create post: 123456function createPost(post, callback) &#123; setTimeout(() =&gt; &#123; posts.push(post); callback(); &#125;, 2000);&#125; callback() has to be inside of setTimeout() , otherwise, callback() will run without waiting post.push(). This is the feature of async programming. Then we can trigger createPost() 1createPost(&#123;title: &#x27;post 3&#x27;, body: &#x27;this is post three&#x27;&#125;, getPosts); You will see “post 1” and “post 2” first and then 2 seconds later, “post 3” shows up. Promise example:We can modify createPost to make it return promise: 123456789101112131415function createPost(post) &#123; return new Promise((resolve, reject) =&gt; &#123; // has to have 2 parameters to indicate callback functions to handle resolve and reject setTimeout(() =&gt; &#123; posts.push(post); const error = false; if (!error) &#123; resolve(); &#125; else &#123; reject(&#x27;Error !&#x27;); &#125; &#125;, 2000); &#125;);&#125; Then call the function: 123createPost(&#123; title: &#x27;post 3&#x27;, body: &#x27;this is post three&#x27;&#125;) .then(getPosts) .catch(err =&gt; console.log(err)); This has the same effect as using callback function mentioned above. If we change error to true in createPost , the catch will handle the error, which is console.log. In addition, we can handle multiple promises: 123456789const promise1 = Promise.resolve(&#x27;hello&#x27;);const promise2 = 10;const promise3 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 2000, &#x27;goodbye&#x27;));const promise4 = fetch(&#x27;&#x27;)Promise.all([promise1, promise2, promise3]) .then((values) =&gt; console.log(values)); Result: 1[&#x27;hello&#x27;, 10, &#x27;goodbye&#x27;] Async example:Async function is more elegant. So we don’t need .then() of promise. createPost function is the same as the previous one. Then, we need the keyword async before the function that triggers createPost and getPosts. And put await before the function createPost which needs to be waited until completed. 123456async function init() &#123; await createPost(&#123; title: &#x27;post 3&#x27;, body: &#x27;this is post three&#x27;&#125;); getPosts();&#125;init(); init will start createPost. Once createPost is completed, it will trigger getPosts","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://mengqiu.me/categories/Javascript/"}],"tags":[{"name":"Syntax","slug":"Syntax","permalink":"https://mengqiu.me/tags/Syntax/"},{"name":"Async","slug":"Async","permalink":"https://mengqiu.me/tags/Async/"}]},{"title":"Desctructuring object","slug":"Desctructuring-object","date":"2022-01-25T16:53:59.000Z","updated":"2022-01-25T16:55:10.777Z","comments":true,"path":"2022/01/25/Desctructuring-object/","link":"","permalink":"https://mengqiu.me/2022/01/25/Desctructuring-object/","excerpt":"In a destructuring assignment, the value on the righthand side of the equals sign is an array or object (a “structured” value), and the lefthand side specifies one or more variable names using a syntax that mimics array and object literal syntax. When a destructuring assignment occurs, one or more values are extracted (“destructured”) from the value on the right and stored into the variables named on the left.","text":"In a destructuring assignment, the value on the righthand side of the equals sign is an array or object (a “structured” value), and the lefthand side specifies one or more variable names using a syntax that mimics array and object literal syntax. When a destructuring assignment occurs, one or more values are extracted (“destructured”) from the value on the right and stored into the variables named on the left. 123456let [x,y] = [1,2];console.log(x,y); // print 1 2[x,y] = [y,x]console.log(x,y); // print 2 1[x,y] = [x+1, y+1];console.log(x,y); // print 3 2 123456789const o = &#123; x: 1, y: 2 &#125;;console.log(Object.entries(o)); // print [[&#x27;x&#x27;, 1], [&#x27;y&#x27;, 2]]for (const [name, value] of Object.entries(o)) &#123; console.log(name, value);&#125; // print x 1 and y 2let &#123;x, y&#125; = o; // extract from object oconsole.log(x); // 1console.log(y); // 2 Destructuring function parameter To extract attribute from object in function parameter: 12345678const person = &#123; name: &#x27;max&#x27;, age: 29&#125;;const getName = function (&#123; name &#125;) &#123; console.log(name);&#125;getName(person); // print &#x27;max&#x27;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://mengqiu.me/categories/Javascript/"}],"tags":[{"name":"Syntax","slug":"Syntax","permalink":"https://mengqiu.me/tags/Syntax/"}]},{"title":"Spread and rest operator","slug":"Spread-and-rest-operator","date":"2022-01-24T16:24:08.000Z","updated":"2022-01-24T16:28:19.516Z","comments":true,"path":"2022/01/24/Spread-and-rest-operator/","link":"","permalink":"https://mengqiu.me/2022/01/24/Spread-and-rest-operator/","excerpt":"Spread operator ... is used to unpack or “spread out” the elements of an array (or any other iterable object, such as string) in a context where individual values are expected.Rest operator ... is used to pack arguments of a function.","text":"Spread operator ... is used to unpack or “spread out” the elements of an array (or any other iterable object, such as string) in a context where individual values are expected.Rest operator ... is used to pack arguments of a function. 1234let s = &quot;4213&quot;;const arr = [4,2,1,3];console.log(Math.min(...s)); // print 1console.log(Math.min(...arr)); // print 1 Rest operator ... is used to write functions that can be invoked with arbitrarily more arguments than parameters. 12345678910111213function max(first=-Infinity, ...rest) &#123; let maxValue = first; // Start by assuming the first arg is biggest // Then loop through the rest of the arguments, looking for bigger for(let n of rest) &#123; if (n &gt; maxValue) &#123; maxValue = n; &#125; &#125; // Return the biggest return maxValue;&#125;max(1, 10, 100, 2, 3, 1000, 4, 5, 6) // =&gt; 1000 The spread operator for function call When we use ... in function definition, it has the opposite effect to the spread operator. Using ... in a function definition gathers multiple function arguments into an array. Rest parameters and the spread operator are often useful together 12345function f (...args) &#123; console.log (args);&#125;f(1,2,3,4); // print &quot;[1,2,3,4]&quot; 1234567891011function f (innerf) &#123; return function (...arg) &#123; // ...arg is the arguments passed to f(innerf) return innerf(...arg); &#125;&#125;function innerf(...x) &#123; console.log(...x);&#125;f(innerf)(1,2,3,4); // print &quot;1 2 3 4&quot;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://mengqiu.me/categories/Javascript/"}],"tags":[{"name":"Syntax","slug":"Syntax","permalink":"https://mengqiu.me/tags/Syntax/"}]},{"title":"JavaScript function","slug":"JavaScript-function","date":"2022-01-24T07:07:25.000Z","updated":"2022-01-24T16:23:40.365Z","comments":true,"path":"2022/01/24/JavaScript-function/","link":"","permalink":"https://mengqiu.me/2022/01/24/JavaScript-function/","excerpt":"JS functions are parameterized. They have a list of identifiers, known as parameters, that work as local variables for the body of the function. In addition to the arguments, each invocation has another value — the invocation context: the value of this keyword. It’s a good idea to use const for function name. Function defined with expressions can’t be invoked before they are defined.","text":"JS functions are parameterized. They have a list of identifiers, known as parameters, that work as local variables for the body of the function. In addition to the arguments, each invocation has another value — the invocation context: the value of this keyword. It’s a good idea to use const for function name. Function defined with expressions can’t be invoked before they are defined. Example: 1234567891011console.log(hello1());console.log(hello2());function hello1 () &#123; console.log(&quot;hello world&quot;);&#125;;// hello2 will throw exception as it&#x27;s called before initializationconst hello2 = function () &#123; console.log(&quot;hello world&quot;);&#125;; In short, with arrow functions there are no binding of this. In regular functions the this keyword represented the object that called the function, which could be the window, the document, a button or whatever. With arrow functions the this keyword always represents the object that defined the arrow function. 1234567891011121314151617181920window.name = &quot;global&quot;; // In nodejs, there&#x27;s no global variable called windowvar person = &#123; name: &quot;jason&quot;, shout: function () &#123; console.log(&quot;my name is &quot;, this.name); &#125;, shout2: () =&gt; &#123; console.log(&quot;my name is &quot;, this.name); &#125;, // Shorter syntax shout3() &#123; console.log(&quot;my name is &quot;, this.name); &#125;&#125;;person.shout(); // &quot;jason&quot;person.shout2(); // &quot;global&quot;person.shout3(); // &quot;jason&quot;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://mengqiu.me/categories/Javascript/"}],"tags":[{"name":"Syntax","slug":"Syntax","permalink":"https://mengqiu.me/tags/Syntax/"}]}],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://mengqiu.me/categories/Javascript/"},{"name":"Project","slug":"Project","permalink":"https://mengqiu.me/categories/Project/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://mengqiu.me/tags/NodeJS/"},{"name":"Server","slug":"Server","permalink":"https://mengqiu.me/tags/Server/"},{"name":"IPv4","slug":"IPv4","permalink":"https://mengqiu.me/tags/IPv4/"},{"name":"REST","slug":"REST","permalink":"https://mengqiu.me/tags/REST/"},{"name":"API","slug":"API","permalink":"https://mengqiu.me/tags/API/"},{"name":"Routing","slug":"Routing","permalink":"https://mengqiu.me/tags/Routing/"},{"name":"Syntax","slug":"Syntax","permalink":"https://mengqiu.me/tags/Syntax/"},{"name":"Async","slug":"Async","permalink":"https://mengqiu.me/tags/Async/"}]}